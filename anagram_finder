import urllib.request
from collections import Counter


def find_all_anagrams(user_input, max_words=3):
    # --- 1. SETUP & DICTIONARY LOADER ---
    print("Loading dictionary... (this happens once)")
    url = "https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt"
    try:
        with urllib.request.urlopen(url) as response:
            all_words = response.read().decode('utf-8').splitlines()
    except Exception as e:
        return [f"Error downloading dictionary: {e}"]

    # --- 2. PRE-PROCESSING ---
    # Clean input: lowercase, keep only letters
    source_str = "".join(filter(str.isalpha, user_input.lower()))
    source_count = Counter(source_str)

    # Filter dictionary: Keep words that can actually be formed by the input
    candidates = []
    for word in all_words:
        word = word.lower()
        # Optimization: Skip tiny words to reduce noise (unless 'a' or 'i')
        if len(word) < 2 and word not in ['a', 'i']:
            continue

        word_count = Counter(word)
        # Check if word is a subset of source letters
        if all(word_count[char] <= source_count[char] for char in word_count):
            candidates.append(word)

    # Sort candidates by length (longest first finds interesting phrases faster)
    candidates.sort(key=len, reverse=True)

    print(f"Processing '{user_input}' ({len(source_str)} letters)...")
    print(f"Found {len(candidates)} candidate words compatible with your letters.")
    print("-" * 40)

    found_anagrams = set()

    # --- 3. RECURSIVE SOLVER ---
    def backtrack(current_phrase, letter_pool):
        # Base Case: If pool is empty, we found a perfect anagram
        if sum(letter_pool.values()) == 0:
            phrase = " ".join(current_phrase)
            if phrase not in found_anagrams:
                # Print immediately so user sees progress
                print(f"FOUND: {phrase.title()}")
                found_anagrams.add(phrase)
            return

        # Constraint: Stop if we exceed max word count (prevents infinite running)
        if len(current_phrase) >= max_words:
            return

        # Try to find the next word
        for word in candidates:
            # Optimization: Only check words that fit inside current letter_pool
            # (We do a quick length check first for speed)
            if len(word) > sum(letter_pool.values()):
                continue

            word_count = Counter(word)

            # Check if this word can be built from remaining letters
            if all(word_count[char] <= letter_pool[char] for char in word_count):
                # Create new pool with letters subtracted
                new_pool = letter_pool - word_count

                # RECURSE: Go deeper
                backtrack(current_phrase + [word], new_pool)

    # Start the search
    backtrack([], source_count)

    if not found_anagrams:
        print("No exact multi-word anagrams found with current constraints.")
    else:
        print("-" * 40)
        print(f"Search complete. Found {len(found_anagrams)} variations.")


# --- RUN IT ---
user_phrase = input("Enter phrase: ")
# Note: max_words=3 prevents the script from running forever on long names
find_all_anagrams(user_phrase, max_words=3)
